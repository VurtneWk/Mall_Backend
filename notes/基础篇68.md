## 68、商品服务-API-品牌管理-JSR303分组校验

场景：`brandId` 字段，在新增时不能传递，但是更改、删除等时，必须传递。

### 实现步骤

> 创建两个接口

```kotlin
interface AddGroup {
}
interface UpdateGroup {
}
```

> 然后在属性上指明什么情况下校验

```kotlin
    @TableId
    @field:Null(message = "新增不能指定ID", groups = [AddGroup::class])
    @field:NotNull(message = "修改必须指定品牌ID", groups = [UpdateGroup::class])
    var brandId: Long? = null,
```

> 最后需要修改controller,用于标注验证哪个分组

```kotlin
    @RequestMapping("/save")
    fun save(@RequestBody @Validated(AddGroup::class)  brand: BrandEntity): R {
        brandService.save(brand)
        return R.ok()
    }

    @RequestMapping("/update")
    fun update(@RequestBody @Validated(UpdateGroup::class) brand: BrandEntity): R {
        brandService.updateById(brand)
        return R.ok()
    }
```

> [!caution]
>
> 当 @Validated(UpdateGroup::class) 添加分组后，未进行分组的属性，将失效，不再验证

```kotlin
    @field:URL(message = "logo必须是一个合法的url地址" ,  groups = [AddGroup::class, UpdateGroup::class])
    @field:NotBlank( groups = [AddGroup::class])
    var logo: String = "",
```

这个说明：新增时不能为空，也必须合法； 修改时可以不携带，但是如果有就必须合法

## 69、商品服务-API-品牌管理-JSR303自定义校验注解

### 编写一个自定义注解校验器

```kotlin
package com.vurtnewk.common.valid

import jakarta.validation.Constraint
import jakarta.validation.Payload
import kotlin.reflect.KClass
import kotlin.annotation.AnnotationTarget.*

/**
 * createTime:  2025/1/8 13:57
 * author:      vurtnewk
 * description: 整数校验注解
 */
@MustBeDocumented
@Constraint(validatedBy = [ListIntValueConstraintValidator::class])
@Target(FIELD, FUNCTION, ANNOTATION_CLASS, CONSTRUCTOR, VALUE_PARAMETER, TYPE)
@Retention(AnnotationRetention.RUNTIME)
annotation class ListIntValue(
    //这里是错误时的提示信息
    val message: String = "{com.vurtnewk.common.valid.ListIntValue.message}",
    val groups: Array<KClass<*>> = [],
    val payload: Array<KClass<out Payload>> = [],
    val values: IntArray = []
)
```

@Constraint(validatedBy = [ListIntValueConstraintValidator::class]) 可以配置多个值

```kotlin
package com.vurtnewk.common.valid

import jakarta.validation.ConstraintValidator
import jakarta.validation.ConstraintValidatorContext

/**
 * 配合[ListIntValue]使用
 * @author   vurtnewk
 * @since    2025/1/8 14:17
 */
class ListIntValueConstraintValidator : ConstraintValidator<ListIntValue, Int> {

    private val set = mutableSetOf<Int>()

    /**
     * 初始化的方法
     */
    override fun initialize(constraintAnnotation: ListIntValue?) {
        super.initialize(constraintAnnotation)
        constraintAnnotation?.values?.forEach {
            set.add(it)
        }
    }
    /**
     * 校验数据
     * @param value 需要校验的值
     */
    override fun isValid(value: Int?, context: ConstraintValidatorContext?): Boolean {
        return set.contains(value)
    }

}
```

使用：

```kotlin
@field:ListIntValue(values = [1, 0], groups = [AddGroup::class])
var showStatus: Int = 1,
```

