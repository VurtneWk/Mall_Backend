## 68、商品服务-API-品牌管理-JSR303分组校验

场景：`brandId` 字段，在新增时不能传递，但是更改、删除等时，必须传递。

### 实现步骤

> 创建两个接口

```kotlin
interface AddGroup {
}
interface UpdateGroup {
}
```

> 然后在属性上指明什么情况下校验

```kotlin
    @TableId
    @field:Null(message = "新增不能指定ID", groups = [AddGroup::class])
    @field:NotNull(message = "修改必须指定品牌ID", groups = [UpdateGroup::class])
    var brandId: Long? = null,
```

> 最后需要修改controller,用于标注验证哪个分组

```kotlin
    @RequestMapping("/save")
    fun save(@RequestBody @Validated(AddGroup::class)  brand: BrandEntity): R {
        brandService.save(brand)
        return R.ok()
    }

    @RequestMapping("/update")
    fun update(@RequestBody @Validated(UpdateGroup::class) brand: BrandEntity): R {
        brandService.updateById(brand)
        return R.ok()
    }
```

> [!caution]
>
> 当 @Validated(UpdateGroup::class) 添加分组后，未进行分组的属性，将失效，不再验证

```kotlin
    @field:URL(message = "logo必须是一个合法的url地址" ,  groups = [AddGroup::class, UpdateGroup::class])
    @field:NotBlank( groups = [AddGroup::class])
    var logo: String = "",
```

这个说明：新增时不能为空，也必须合法； 修改时可以不携带，但是如果有就必须合法

## 69、商品服务-API-品牌管理-JSR303自定义校验注解

### 编写一个自定义注解校验器

```kotlin
package com.vurtnewk.common.valid

import jakarta.validation.Constraint
import jakarta.validation.Payload
import kotlin.reflect.KClass
import kotlin.annotation.AnnotationTarget.*

/**
 * createTime:  2025/1/8 13:57
 * author:      vurtnewk
 * description: 整数校验注解
 */
@MustBeDocumented
@Constraint(validatedBy = [ListIntValueConstraintValidator::class])
@Target(FIELD, FUNCTION, ANNOTATION_CLASS, CONSTRUCTOR, VALUE_PARAMETER, TYPE)
@Retention(AnnotationRetention.RUNTIME)
annotation class ListIntValue(
    //这里是错误时的提示信息
    val message: String = "{com.vurtnewk.common.valid.ListIntValue.message}",
    val groups: Array<KClass<*>> = [],
    val payload: Array<KClass<out Payload>> = [],
    val values: IntArray = []
)
```

@Constraint(validatedBy = [ListIntValueConstraintValidator::class]) 可以配置多个值

```kotlin
package com.vurtnewk.common.valid

import jakarta.validation.ConstraintValidator
import jakarta.validation.ConstraintValidatorContext

/**
 * 配合[ListIntValue]使用
 * @author   vurtnewk
 * @since    2025/1/8 14:17
 */
class ListIntValueConstraintValidator : ConstraintValidator<ListIntValue, Int> {

    private val set = mutableSetOf<Int>()

    /**
     * 初始化的方法
     */
    override fun initialize(constraintAnnotation: ListIntValue?) {
        super.initialize(constraintAnnotation)
        constraintAnnotation?.values?.forEach {
            set.add(it)
        }
    }
    /**
     * 校验数据
     * @param value 需要校验的值
     */
    override fun isValid(value: Int?, context: ConstraintValidatorContext?): Boolean {
        return set.contains(value)
    }

}
```

使用：

```kotlin
@field:ListIntValue(values = [1, 0], groups = [AddGroup::class])
var showStatus: Int = 1,
```

## 70、商品服务-概念-SPU&SKU&规格参数&销售属性

### SPU 与 SKU

#### SPU：Standard Product Unit（标准化产品单元）

是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。

#### SKU：Stock Keeping Unit（库存量单位）

即库存进出计量的基本单元，可以是以件，盒，托盘等为单位。SKU 这是对于大型连锁超市DC（配送中心）物流管理的一个必要的方法。现在已经被引申为产品统一编号的简称，每种产品均对应有唯一的 SKU 号。

### 基本属性【规格参数】与销售属性

每个分类下的商品共享规格参数，与销售属性。只是有些商品不一定要用这个分类下全部的属性；

- 属性是以三级分类组织起来的
- 规格参数中有些是可以提供检索的
- 规格参数也是基本属性，他们具有自己的分组
- 属性的分组也是以三级分类组织起来的
- 属性名确定的，但是值是每一个商品不同来决定的

### 数据库的关系

- `pms_attr` 属性表  比如 机身颜色
- `pms_attr_group` 属性分组表 ， 属性所属的分组
- `pms_attr_attrgroup_relation` 属性分组表和属性表的关联表
- `pms_product_attr_value` 商品属性值表  属性表的值是什么，是根据具体商品来的
- `pms_spu_info` SPU真正的信息
- `pms_sku_info` SKU的真正信息
- `pms_sku_sale_attr_value` SKU的销售属性表，比如蓝色、红色等

![image-20250108162853825](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202501081628918.png) 

> [!note]
>
> 根据三级分类能查出有哪些分组，根据分组关联表，能查出对应的属性表

![image-20250108162656871](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202501081626951.png) 

> [!note]
>
> - 根据spu 能获取对应的属性
> - 每个spu下有不同的sku，根据sku_sale_attr_value表 能获取对应spu的不同sku的属性

## 71、商品服务-API-属性分组-前端组件抽取&父子组件交互 

> [!caution]
>
> 导入前端Vue 页面

## 72、商品服务-API-属性分组-获取分类属性分组

> [!caution]
>
> Kotlin 坑
>
> 分页插件 坑

### Kotlin使用MyBatis puls

> 使用的KtQueryChainWrapper 或者普通Query查询，普通Query只支持数据库名的方法，如果字段名变了就比较麻烦

```kotlin
    override fun queryPage(params: Map<String, Any>, catelogId: Long): PageUtils {
        val iPage = Query<AttrGroupEntity>().getPage(params)
        return if (catelogId == 0L) {
            KtQueryChainWrapper(AttrGroupEntity::class.java)
                .page(iPage)
                .utils()
        } else {
            //select * from pms_attr_group where catelog_id = ? and (attr_group_id = key or attr_group_name like key)
            val key = params["key"] as String?

            KtQueryChainWrapper(AttrGroupEntity::class.java)
                .eq(AttrGroupEntity::catelogId, catelogId)
                .and(!key.isNullOrEmpty()) {
                    it.eq(AttrGroupEntity::attrGroupId, key)
                        .or().like(AttrGroupEntity::attrGroupName, key)
                }
                .page(iPage)
                .utils()
        }
    }
```

>  uitls是自己写的扩展

```kotlin
fun IPage<*>.utils(): PageUtils {
    return PageUtils(this)
}
```

> java 写法

```java
    @Override
    public PageUtils queryPage(Map<String, Object> params, Long catelogId) {
        QueryWrapper<AttrGroupEntity> wrapper = new QueryWrapper<>();
        if (params.containsKey("key")) {
            String key = (String) params.get("key");
            if (!StringUtils.isEmpty(key)) {
                wrapper.and(obj -> obj.eq("attr_group_id", key).or().like("attr_group_name", key));
            }
        }
        if (catelogId != 0) {
            wrapper.eq("catelog_id", catelogId);
        }
        IPage<AttrGroupEntity> page = page(new Query<AttrGroupEntity>().getPage(params), wrapper);
        return new PageUtils(page);
    }
```

### 分页插件

> 我使用的mybatis plus 3.5.9 所以被拆分了依赖需要加上 (不然没有PaginationInnerInterceptor类)

```xml
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-jsqlparser</artifactId>
            <version>3.5.9</version> <!-- 确保版本和 MyBatis Plus 主包一致 -->
        </dependency>
```

> 编写分页拦截器

```kotlin
package com.vurtnewk.mall.product.config

import com.baomidou.mybatisplus.annotation.DbType
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor
import org.mybatis.spring.annotation.MapperScan
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.transaction.annotation.EnableTransactionManagement

/**
 * 分页插件
 * @author   vurtnewk
 * @since    2025/1/8 23:30
 */
@Configuration
@EnableTransactionManagement //开启事务
@MapperScan("com.vurtnewk.mall.product.dao")
class MyBatisConfig {

    @Bean
    fun mybatisPlusInterceptor(): MybatisPlusInterceptor {
        return MybatisPlusInterceptor().apply {
            addInnerInterceptor(PaginationInnerInterceptor(DbType.MYSQL))
        }
    }
}
```

## 73、商品服务-API-属性分组-分组新增&级联选择器

### 后端隐藏某个字段 JsonInclude

```kotlin
    /**
     * 当前分类的子分类
     * 因为不在数据库中存在的字段，所以需要添加@TableField(exist = false)
     * @JsonInclude(JsonInclude.Include.NON_EMPTY) 当数据时空的时候，不传给前端
     */
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @TableField(exist = false)
    var children: MutableList<CategoryEntity> = mutableListOf()
```

### kotlin的另一个小问题

restful tool 插件不能识别kotlin写的controller 

### 前端隐藏某个字段

```js
getTreeData(data) {
  for (var i = 0; i < data.length; i++) {
    if (data[i].children.length < 1) {
      // children若为空数组，则将children设为undefined
      data[i].children = undefined;
    } else {
      // children若不为空数组，则继续 递归调用 本方法
      this.getTreeData(data[i].children);
    }
  }
  return data;
}
```

## 74、商品服务-API-属性分组-分组修改&级联选择器回显

### log 日志

> 如果需要使用@Slf4j注解，需要导入lombok依赖，但是kotlin不支持这个注解。所以直接使用了扩展函数

```kotlin
package com.vurtnewk.common.utils.ext

import org.slf4j.Logger
import org.slf4j.LoggerFactory

/**
 * slf4j 支持
 * 扩展方法，不用导入注解 直接使用
 * https://blog.csdn.net/DCTANT/article/details/134007369
 * @author   vurtnewk
 * @since    2025/1/10 12:59
 */

fun <T : Any> T.logger(): Logger {
    return LoggerFactory.getLogger(this.javaClass)
}

fun <T : Any> T.logError(e: Throwable) {
    logger().error("", e)
}

fun <T : Any> T.logError(msg: String) {
    logger().error(msg)
}

fun <T : Any> T.logInfo(msg: String) {
    logger().info(msg)
}

fun <T : Any> T.logDebug(msg: String) {
    logger().debug(msg)
}

```

## 75、商品服务-API-品牌管理-品牌分类关联与级联更新

### 前端代码复制

 modules/common modules/product

### 后端

> 获取当前品牌关联的所有分类列表

```kotlin
    /**
     * 获取当前品牌关联的所有分类列表
     */
//    @RequestMapping(value = ["/catelog/list"], method = [RequestMethod.GET])
    @GetMapping("/catelog/list")
    //@RequiresPermissions("product:categorybrandrelation:list")
    fun cateloglist(@RequestParam brandId: Long): R {
        val list = KtQueryChainWrapper(CategoryBrandRelationEntity::class.java)
            .eq(CategoryBrandRelationEntity::brandId, brandId)
            .list()
        return R.ok().put("data", list)
    }
```

### 注意点

![image-20250110162220113](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202501101622303.png)

因为关联分类里有直接显示，品牌名、分类名，如果每次都去 `pms_brand`表 和 `pms_category` 表中查询名字，涉及的查询会较多。



![image-20250110161910239](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202501101619600.png)

所以`pms_category_brand_relation` 中冗余存储了 brand name 以及 catelog name 。

不过这就需要在修改brand name , catelog name 时都要额外记得修改 各个冗余字段里的数据

```kotlin
    override fun updateCascade(brand: BrandEntity) {
        this.updateById(brand) //更改自己
        if (!brand.name.isNullOrEmpty()) {
            //需要更新关联表中的数据
            mCategoryBrandRelationService.updateBrandName(brand.brandId!!, brand.name!!)
        }
    }
//-------------
    override fun updateBrandName(brandId: Long, name: String) {
        val categoryBrandRelationEntity = CategoryBrandRelationEntity(brandName = name)
        KtUpdateChainWrapper(CategoryBrandRelationEntity::class.java)
            .eq(CategoryBrandRelationEntity::brandId, brandId)
            .update(categoryBrandRelationEntity)
    }
```

具体细节查看代码，这里的更改，brand name 使用的代码，而catelog name 使用的mapper映射的SQL

> [!caution]
>
> kotlin写的dao mapper文件，不能通过mybatisx 插件自动生成xml的语句。（手动生成后可以点击来回跳转）
>
> 另外别忘记加事务

## 76、商品服务-API-平台属性-规格参数新增与VO

### 之前的 属性分组--查询全部时 不支持模糊查询

> AttrGroupServiceImpl 进行更改

```kotlin
    override fun queryPage(params: Map<String, Any>, catelogId: Long): PageUtils {
        val iPage = Query<AttrGroupEntity>().getPage(params)
        val key = params["key"] as String?
        //select * from pms_attr_group where catelog_id = ? and (attr_group_id = key or attr_group_name like key)
        val ktQueryChainWrapper = KtQueryChainWrapper(AttrGroupEntity::class.java)
            .and(!key.isNullOrEmpty()) {
                it.eq(AttrGroupEntity::attrGroupId, key)
                    .or().like(AttrGroupEntity::attrGroupName, key)
            }
        if (catelogId != 0L) {
            ktQueryChainWrapper.eq(AttrGroupEntity::catelogId, catelogId)
        }
        return ktQueryChainWrapper.page(iPage).pageUtils()
    }
```

### 新增规格参数

![image-20250110171523542](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202501101715588.png) 

每个规格参数(pms_attr)，都有对应的一个分组(pms_attr_group) , 他们的关系是保存在（pms_attr_attrgroup_relation）

现在新增时，并没有保存这个关系

> [!note]
>
> AttrEntity 中并没有attrGroupId这个属性，所以需要新加attrGroupId属性，但是他又并不在数据库中，所以按照分层思想，新进VO

> AttrVO

```kotlin
package com.vurtnewk.mall.product.vo

import com.baomidou.mybatisplus.annotation.TableId
import java.io.Serializable

/**
 * 商品属性 Vo
 * @author   vurtnewk
 * @since    2025/1/10 17:17
 */

data class AttrVO(
    /**
     * 属性id
     */
    @TableId
    var attrId: Long? = null,
    /**
     * 属性名
     */
    var attrName: String? = null,
    /**
     * 是否需要检索[0-不需要，1-需要]
     */
    var searchType: Int? = null,
    /**
     * 属性图标
     */
    var icon: String? = null,
    /**
     * 可选值列表(用逗号分隔)
     */
    var valueSelect: String? = null,
    /**
     * 属性类型[0-销售属性，1-基本属性，2-既是销售属性又是基本属性]
     */
    var attrType: Int? = null,
    /**
     * 启用状态[0 - 禁用，1 - 启用]
     */
    var enable: Long? = null,
    /**
     * 所属分类
     */
    var catelogId: Long? = null,
    /**
     * 快速展示【是否展示在介绍上；0-否 1-是】，在sku中仍然可以调整
     */
    var showDesc: Int? = null,
    /**
     * 属性所属的分组
     */
    var attrGroupId: Long? = null
) : Serializable
```

> AttrController 的save就需要进行修改

```kotlin
    @RequestMapping("/save")
    //@RequiresPermissions("product:attr:save")
    fun save(@RequestBody attr: AttrEntity): R {
        attrService.save(attr)
        return R.ok()
    }

    @RequestMapping("/save")
    //@RequiresPermissions("product:attr:save")
    fun save(@RequestBody attr: AttrVO): R {
        attrService.saveAttrVO(attr)
        return R.ok()
    }
```

> AttrServiceImpl

```kotlin
    @Transactional
    override fun saveAttrVO(attr: AttrVO) {
        //1.保存自己到属性表
        val attrEntity = AttrEntity()
        BeanUtils.copyProperties(attr, attrEntity)
        this.save(attrEntity)
        //2.保存所属分组到关联表
        val entity = AttrAttrgroupRelationEntity()
        entity.attrGroupId = attr.attrGroupId
        entity.attrId = attrEntity.attrId
        mAttrAttrgroupRelationDao.insert(entity)
    }
```

### Object 划分

在软件开发中，对象的划分是一种常见的设计模式，主要用于分离关注点、提升代码的可读性和可维护性。以下是常见的几种对象分类及其作用：

------

#### **1. DO（Data Object / Domain Object）数据对象 / 领域对象**

##### **作用：**

- 表现系统中的核心业务逻辑。
- 通常与数据库中的表结构直接对应。
- 用于封装业务领域中的核心数据和行为。

##### **使用场景：**

- 数据持久化：保存到数据库或从数据库加载。
- 领域建模：反映业务领域的概念和规则。

##### **特点：**

- 可能包含数据校验逻辑。
- 一般不直接用于视图或接口。

------

#### **2. VO（Value Object）值对象**

##### **作用：**

- 表现只读的业务数据传输结构。
- 用于在不同层之间传递数据，通常无行为，仅承载数据。

##### **使用场景：**

- 数据传输：从服务端向客户端传递数据，或者在应用内部不同模块间传递数据。
- 接口返回值：REST API 或 RPC 的返回对象。

##### **特点：**

- 不包含业务逻辑。
- 通常是不可变对象（Immutable）。

------

#### **3. DTO（Data Transfer Object）数据传输对象**

##### **作用：**

- 用于在应用层之间传递数据，通常是针对特定接口的定制数据结构。
- 目的是优化网络或接口调用，减少传输数据量。

##### **使用场景：**

- 前后端交互：将后端 DO 转换为前端需要的字段，或反过来。
- 微服务间通信：对跨服务的数据进行封装和结构化。

##### **特点：**

- 包含特定场景需要的字段，可能与 DO、VO 不同。
- 不包含业务逻辑。

------

#### **4. PO（Persistent Object）持久化对象**

##### **作用：**

- 表现与数据库表一一对应的对象，用于直接操作数据库。
- 主要用于持久化层，和 ORM（如 Hibernate、MyBatis）配合使用。

##### **使用场景：**

- 数据库操作：增删改查操作的实体对象。
- 通常在 DAO 层或 Repository 层出现。

##### **特点：**

- 和数据库字段严格对应。
- 通常不包含复杂的业务逻辑。

------

#### **5. BO（Business Object）业务对象**

##### **作用：**

- 封装业务逻辑和规则，是业务层的核心对象。
- 主要用于协调多个 DO 的操作，处理复杂的业务场景。

##### **使用场景：**

- 业务层：实现复杂的业务逻辑。
- 服务组合：在一个业务操作中操作多个 PO/DO。

##### **特点：**

- 包含业务行为和逻辑。
- 可能聚合多个其他对象。

------

#### **6. AO（Application Object）应用对象**

##### **作用：**

- 用于表示特定应用场景下的对象，一般是接口层和服务层之间的桥梁。
- 在服务调用中，帮助封装特定的应用逻辑。

##### **使用场景：**

- Web 应用：封装与用户界面交互的数据。
- 应用层：简化业务逻辑的传递。

##### **特点：**

- 接近应用层和用户交互层。

------

#### **7. RO（Result Object）结果对象**

##### **作用：**

- 用于封装接口的统一返回结果。
- 包含结果状态码、消息、数据等。

##### **使用场景：**

- 接口设计：REST API 或 RPC 的统一响应格式。
- 错误处理：携带错误码和信息。

##### **特点：**

- 标准化的返回结构。
- 提升接口一致性和易用性。

------

#### **分类间关系与注意事项：**

1. **清晰职责：** 各类对象应该有明确的职责，不同类型的对象避免混用。
2. **转换逻辑：** 通常在不同层之间需要对象的转换，如从 DO 转为 VO 或 DTO。
3. **简化复杂性：** 使用这些分类能够简化复杂系统的分层设计，提升代码可维护性。

