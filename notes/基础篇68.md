## 68、商品服务-API-品牌管理-JSR303分组校验

场景：`brandId` 字段，在新增时不能传递，但是更改、删除等时，必须传递。

### 实现步骤

> 创建两个接口

```kotlin
interface AddGroup {
}
interface UpdateGroup {
}
```

> 然后在属性上指明什么情况下校验

```kotlin
    @TableId
    @field:Null(message = "新增不能指定ID", groups = [AddGroup::class])
    @field:NotNull(message = "修改必须指定品牌ID", groups = [UpdateGroup::class])
    var brandId: Long? = null,
```

> 最后需要修改controller,用于标注验证哪个分组

```kotlin
    @RequestMapping("/save")
    fun save(@RequestBody @Validated(AddGroup::class)  brand: BrandEntity): R {
        brandService.save(brand)
        return R.ok()
    }

    @RequestMapping("/update")
    fun update(@RequestBody @Validated(UpdateGroup::class) brand: BrandEntity): R {
        brandService.updateById(brand)
        return R.ok()
    }
```

> [!caution]
>
> 当 @Validated(UpdateGroup::class) 添加分组后，未进行分组的属性，将失效，不再验证

```kotlin
    @field:URL(message = "logo必须是一个合法的url地址" ,  groups = [AddGroup::class, UpdateGroup::class])
    @field:NotBlank( groups = [AddGroup::class])
    var logo: String = "",
```

这个说明：新增时不能为空，也必须合法； 修改时可以不携带，但是如果有就必须合法

## 69、商品服务-API-品牌管理-JSR303自定义校验注解

### 编写一个自定义注解校验器

```kotlin
package com.vurtnewk.common.valid

import jakarta.validation.Constraint
import jakarta.validation.Payload
import kotlin.reflect.KClass
import kotlin.annotation.AnnotationTarget.*

/**
 * createTime:  2025/1/8 13:57
 * author:      vurtnewk
 * description: 整数校验注解
 */
@MustBeDocumented
@Constraint(validatedBy = [ListIntValueConstraintValidator::class])
@Target(FIELD, FUNCTION, ANNOTATION_CLASS, CONSTRUCTOR, VALUE_PARAMETER, TYPE)
@Retention(AnnotationRetention.RUNTIME)
annotation class ListIntValue(
    //这里是错误时的提示信息
    val message: String = "{com.vurtnewk.common.valid.ListIntValue.message}",
    val groups: Array<KClass<*>> = [],
    val payload: Array<KClass<out Payload>> = [],
    val values: IntArray = []
)
```

@Constraint(validatedBy = [ListIntValueConstraintValidator::class]) 可以配置多个值

```kotlin
package com.vurtnewk.common.valid

import jakarta.validation.ConstraintValidator
import jakarta.validation.ConstraintValidatorContext

/**
 * 配合[ListIntValue]使用
 * @author   vurtnewk
 * @since    2025/1/8 14:17
 */
class ListIntValueConstraintValidator : ConstraintValidator<ListIntValue, Int> {

    private val set = mutableSetOf<Int>()

    /**
     * 初始化的方法
     */
    override fun initialize(constraintAnnotation: ListIntValue?) {
        super.initialize(constraintAnnotation)
        constraintAnnotation?.values?.forEach {
            set.add(it)
        }
    }
    /**
     * 校验数据
     * @param value 需要校验的值
     */
    override fun isValid(value: Int?, context: ConstraintValidatorContext?): Boolean {
        return set.contains(value)
    }

}
```

使用：

```kotlin
@field:ListIntValue(values = [1, 0], groups = [AddGroup::class])
var showStatus: Int = 1,
```

## 70、商品服务-概念-SPU&SKU&规格参数&销售属性

### SPU 与 SKU

#### SPU：Standard Product Unit（标准化产品单元）

是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。

#### SKU：Stock Keeping Unit（库存量单位）

即库存进出计量的基本单元，可以是以件，盒，托盘等为单位。SKU 这是对于大型连锁超市DC（配送中心）物流管理的一个必要的方法。现在已经被引申为产品统一编号的简称，每种产品均对应有唯一的 SKU 号。

### 基本属性【规格参数】与销售属性

每个分类下的商品共享规格参数，与销售属性。只是有些商品不一定要用这个分类下全部的属性；

- 属性是以三级分类组织起来的
- 规格参数中有些是可以提供检索的
- 规格参数也是基本属性，他们具有自己的分组
- 属性的分组也是以三级分类组织起来的
- 属性名确定的，但是值是每一个商品不同来决定的

### 数据库的关系

- `pms_attr` 属性表  比如 机身颜色
- `pms_attr_group` 属性分组表 ， 属性所属的分组
- `pms_attr_attrgroup_relation` 属性分组表和属性表的关联表
- `pms_product_attr_value` 商品属性值表  属性表的值是什么，是根据具体商品来的
- `pms_spu_info` SPU真正的信息
- `pms_sku_info` SKU的真正信息
- `pms_sku_sale_attr_value` SKU的销售属性表，比如蓝色、红色等

![image-20250108162853825](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202501081628918.png) 

> [!note]
>
> 根据三级分类能查出有哪些分组，根据分组关联表，能查出对应的属性表

![image-20250108162656871](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202501081626951.png) 

> [!note]
>
> - 根据spu 能获取对应的属性
> - 每个spu下有不同的sku，根据sku_sale_attr_value表 能获取对应spu的不同sku的属性

## 71、商品服务-API-属性分组-前端组件抽取&父子组件交互 

> [!caution]
>
> 导入前端Vue 页面

## 72、商品服务-API-属性分组-获取分类属性分组

> [!caution]
>
> Kotlin 坑
>
> 分页插件 坑

### Kotlin使用MyBatis puls

> 使用的KtQueryChainWrapper 或者普通Query查询，普通Query只支持数据库名的方法，如果字段名变了就比较麻烦

```kotlin
    override fun queryPage(params: Map<String, Any>, catelogId: Long): PageUtils {
        val iPage = Query<AttrGroupEntity>().getPage(params)
        return if (catelogId == 0L) {
            KtQueryChainWrapper(AttrGroupEntity::class.java)
                .page(iPage)
                .utils()
        } else {
            //select * from pms_attr_group where catelog_id = ? and (attr_group_id = key or attr_group_name like key)
            val key = params["key"] as String?

            KtQueryChainWrapper(AttrGroupEntity::class.java)
                .eq(AttrGroupEntity::catelogId, catelogId)
                .and(!key.isNullOrEmpty()) {
                    it.eq(AttrGroupEntity::attrGroupId, key)
                        .or().like(AttrGroupEntity::attrGroupName, key)
                }
                .page(iPage)
                .utils()
        }
    }
```

>  uitls是自己写的扩展

```kotlin
fun IPage<*>.utils(): PageUtils {
    return PageUtils(this)
}
```

> java 写法

```java
    @Override
    public PageUtils queryPage(Map<String, Object> params, Long catelogId) {
        QueryWrapper<AttrGroupEntity> wrapper = new QueryWrapper<>();
        if (params.containsKey("key")) {
            String key = (String) params.get("key");
            if (!StringUtils.isEmpty(key)) {
                wrapper.and(obj -> obj.eq("attr_group_id", key).or().like("attr_group_name", key));
            }
        }
        if (catelogId != 0) {
            wrapper.eq("catelog_id", catelogId);
        }
        IPage<AttrGroupEntity> page = page(new Query<AttrGroupEntity>().getPage(params), wrapper);
        return new PageUtils(page);
    }
```

### 分页插件

> 我使用的mybatis plus 3.5.9 所以被拆分了依赖需要加上 (不然没有PaginationInnerInterceptor类)

```xml
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-jsqlparser</artifactId>
            <version>3.5.9</version> <!-- 确保版本和 MyBatis Plus 主包一致 -->
        </dependency>
```

> 编写分页拦截器

```kotlin
package com.vurtnewk.mall.product.config

import com.baomidou.mybatisplus.annotation.DbType
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor
import org.mybatis.spring.annotation.MapperScan
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.transaction.annotation.EnableTransactionManagement

/**
 * 分页插件
 * @author   vurtnewk
 * @since    2025/1/8 23:30
 */
@Configuration
@EnableTransactionManagement //开启事务
@MapperScan("com.vurtnewk.mall.product.dao")
class MyBatisConfig {

    @Bean
    fun mybatisPlusInterceptor(): MybatisPlusInterceptor {
        return MybatisPlusInterceptor().apply {
            addInnerInterceptor(PaginationInnerInterceptor(DbType.MYSQL))
        }
    }
}
```

## 73、商品服务-API-属性分组-分组新增&级联选择器

### 后端隐藏某个字段 JsonInclude

```kotlin
    /**
     * 当前分类的子分类
     * 因为不在数据库中存在的字段，所以需要添加@TableField(exist = false)
     * @JsonInclude(JsonInclude.Include.NON_EMPTY) 当数据时空的时候，不传给前端
     */
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @TableField(exist = false)
    var children: MutableList<CategoryEntity> = mutableListOf()
```

### kotlin的另一个小问题

restful tool 插件不能识别kotlin写的controller 

### 前端隐藏某个字段

```js
getTreeData(data) {
  for (var i = 0; i < data.length; i++) {
    if (data[i].children.length < 1) {
      // children若为空数组，则将children设为undefined
      data[i].children = undefined;
    } else {
      // children若不为空数组，则继续 递归调用 本方法
      this.getTreeData(data[i].children);
    }
  }
  return data;
}
```

